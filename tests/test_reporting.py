import math
import uuid
from pathlib import Path

import pandas as pd
import pytest

from quantalytics.reporting import html
from quantalytics.reporting.metric_registry import (
    SUMMARY_METRIC_REGISTRY,
    resolve_summary_specs,
)
from quantalytics.reporting.metrics import monthly_returns
from quantalytics.reporting.tearsheet import (
    _format_date_iso,
    _format_date_readable,
    _format_summary_metric,
    _package_version,
    _period_return,
    _scalar_value,
)
from quantalytics.reporting.tearsheet import (
    _resolve_summary_specs as _resolve_summary_specs_tearsheet,
)

DATA_PATH = Path(__file__).with_name("daily_returns.csv")


def sample_returns() -> pd.Series:
    """Returns the deterministic series used for reporting tests."""

    df = pd.read_csv(DATA_PATH, parse_dates=["Date"]).set_index("Date")
    return df["Return"]


def test_html_render_basic_tearsheet():
    returns = sample_returns()
    report = html(returns, title="Custom Tearsheet")
    assert isinstance(report.html, str)
    assert "Custom Tearsheet" in report.html
    assert report.html.strip().startswith("<!DOCTYPE html>")
    assert "4 Nov 2020 â†’ 12 Nov 2025" in report.html
    assert "Generated by Quantalytics (v" in report.html
    assert "Client identity" not in report.html
    assert "Strategy Parameters" not in report.html
    assert "Sharpe Ratio" in report.html


def test_html_accepts_summary_stats_list():
    returns = sample_returns()
    report = html(
        returns, summary_stats=["sharpe", "max_drawdown", "sortino", "romad", "cagr"]
    )
    assert "Sharpe Ratio" in report.html
    assert "Win Rate" in report.html
    assert "CAGR" in report.html


def test_html_handles_empty_returns_branch():
    empty_returns = pd.Series(dtype=float)
    report = html(empty_returns, title="Empty Case")
    assert "Empty Case" in report.html
    assert "Data coverage unavailable" in report.html


def test_package_version_falls_back_for_missing_package():
    missing = f"quantalytics_missing_{uuid.uuid4().hex}"
    assert _package_version(missing) == "0.0.0"


def test_scalar_value_handles_empty_series():
    result = _scalar_value(pd.Series(dtype=float))
    assert math.isnan(result)


def test_format_date_helpers_return_original_string_on_error():
    invalid_date = "not a date"
    assert _format_date_iso(invalid_date) == invalid_date
    assert _format_date_readable(invalid_date) == invalid_date


def test_format_summary_metric_handles_invalid_inputs():
    assert _format_summary_metric(None, scale=1, decimals=2, suffix="%") == "N/A"
    assert _format_summary_metric("bad", scale=1, decimals=2, suffix="%") == "N/A"
    assert (
        _format_summary_metric(pd.Series(dtype=float), scale=1, decimals=2, suffix="%")
        == "N/A"
    )


def test_period_return_falls_back_when_window_is_empty():
    series = pd.Series([0.01, 0.02], index=pd.date_range("2024-01-01", periods=2))
    distant_future = pd.Timestamp("2030-01-01")
    assert _period_return(series, distant_future) == 0.0


def test_html_handles_date_parsing_errors(monkeypatch):
    returns = sample_returns()

    original_to_datetime = pd.to_datetime

    def _fake_to_datetime(value, *args, **kwargs):
        if value is returns.index:
            raise ValueError("boom")
        return original_to_datetime(value, *args, **kwargs)

    monkeypatch.setattr(pd, "to_datetime", _fake_to_datetime)
    report = html(returns, title="Date Error")
    assert "Data coverage unavailable" in report.html


def test_html_supports_log_scale_mode():
    returns = sample_returns()
    report = html(returns, log_scale=True, title="Log Scale")
    assert "Log Scale" in report.html


def test_html_short_series_skips_rolling_metrics():
    dates = pd.date_range("2030-01-01", periods=2)
    series = pd.Series([0.01, 0.02], index=dates)
    report = html(series, title="Short Series")
    assert "Short Series" in report.html


def test_html_includes_header_logo():
    returns = sample_returns()
    logo_url = "https://example.com/logo.png"
    report = html(returns, title="Logo Report", header_logo=logo_url)
    assert f'src="{logo_url}"' in report.html
    assert "Client identity" in report.html


def test_html_renders_parameters_table(tmp_path):
    returns = sample_returns()
    parameters = {"Name": "alpha", "Trade Count": "42"}
    report = html(returns, title="Params", parameters=parameters)
    assert "Strategy Parameters" in report.html
    assert "alpha" in report.html
    assert "42" in report.html
    target = "params.html"
    report.to_html(target)
    # assert target.exists()


def test_metric_registry_resolves_all_registered_keys():
    keys = list(SUMMARY_METRIC_REGISTRY.keys())
    specs = resolve_summary_specs(keys)
    assert len(specs) == len(keys)
    assert all(spec.label for spec in specs)
    assert all(spec.value_key for spec in specs)


def test_tearsheet_summary_specs_reject_unknown_keys():
    with pytest.raises(ValueError):
        _resolve_summary_specs_tearsheet(["not-a-real-spec"])


def test_monthly_returns_basic():
    """Test that monthly_returns creates proper pivot table structure."""
    returns = sample_returns()
    monthly = monthly_returns(returns)

    # Check that result is a DataFrame
    assert isinstance(monthly, pd.DataFrame)

    # Check that all month columns are present (JAN-DEC + EOY)
    expected_cols = [
        "JAN",
        "FEB",
        "MAR",
        "APR",
        "MAY",
        "JUN",
        "JUL",
        "AUG",
        "SEP",
        "OCT",
        "NOV",
        "DEC",
        "EOY",
    ]
    assert list(monthly.columns) == expected_cols

    # Check that years are in the index
    assert len(monthly.index) > 0
    assert all(isinstance(year, str) for year in monthly.index)


def test_monthly_returns_without_eoy():
    """Test monthly_returns without end-of-year column."""
    returns = sample_returns()
    monthly = monthly_returns(returns, eoy=False)

    # Check that EOY column is not present
    expected_cols = [
        "JAN",
        "FEB",
        "MAR",
        "APR",
        "MAY",
        "JUN",
        "JUL",
        "AUG",
        "SEP",
        "OCT",
        "NOV",
        "DEC",
    ]
    assert list(monthly.columns) == expected_cols


def test_monthly_returns_compounded_vs_arithmetic():
    """Test that compounded and arithmetic aggregation produce different results."""
    returns = sample_returns()
    monthly_comp = monthly_returns(returns, compounded=True)
    monthly_arith = monthly_returns(returns, compounded=False)

    # Both should have same structure
    assert monthly_comp.shape == monthly_arith.shape

    # Values should generally differ (though may be close for small returns)
    # Just check that they're not identical
    assert not monthly_comp.equals(monthly_arith)


def test_monthly_returns_with_simple_data():
    """Test monthly_returns with simple synthetic data."""
    # Create a simple test case with known values
    dates = pd.date_range("2023-01-01", "2023-03-31", freq="D")
    returns = pd.Series([0.01] * len(dates), index=dates)

    monthly = monthly_returns(returns, eoy=True, compounded=True)

    # Should have one row for 2023
    assert "2023" in monthly.index

    # January, February, and March should have non-zero values
    assert monthly.loc["2023", "JAN"] != 0
    assert monthly.loc["2023", "FEB"] != 0
    assert monthly.loc["2023", "MAR"] != 0

    # Other months should be 0 (missing data)
    assert monthly.loc["2023", "APR"] == 0
    assert monthly.loc["2023", "DEC"] == 0


def test_monthly_returns_preserves_native_type():
    """Test that monthly_returns returns the same native type as input."""
    # Create pandas Series input
    dates = pd.date_range("2023-01-01", "2023-03-31", freq="D")
    pandas_returns = pd.Series([0.01] * len(dates), index=dates)

    # Call function with pandas Series
    result = monthly_returns(pandas_returns)

    # Result should be a pandas DataFrame (native type preserved)
    assert isinstance(result, pd.DataFrame)
    assert not hasattr(result, "to_pandas")  # Should be native pandas, not narwhals
